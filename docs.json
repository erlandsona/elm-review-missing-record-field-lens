[{"name":"NoMissingRecordFieldLens","comment":"\n\n@docs rule, Config\n\n\n# lens generators\n\n\n## working out of the box\n\n@docs accessors, monocle, fields, zipper\n\n\n## custom\n\n@docs FieldLensGenerator, FieldLensDeclaration, functionsForField, getSetRecordForField, withDocumentation, withName\n\n","unions":[],"aliases":[{"name":"Config","comment":" The [rule](#rule)'s configuration.\n\n  - `generate`: What kind of lens to generate:\n      - [`elm-accessors`](#accessors),\n      - [`elm-fields`](#fields),\n      - [`elm-monocle`](#monocle),\n      - [`zipper`](#zipper) or\n      - [a custom one](#FieldLensGenerator).\n\n  - `generateIn`: The module where all field lenses will be generated in\n\n    understand `( \"Module\", [ \"Name\" ] )` as `Module.Name`\n\n","args":[],"type":"{ generator : NoMissingRecordFieldLens.FieldLensGenerator, generateIn : ( String.String, List.List String.String ) }"},{"name":"FieldLensDeclaration","comment":" All the components to build a field lens declaration:\n\n    {-| [documentation]\n    -}\n    [name] : [annotation]\n    [name] =\n        [implementation]\n\nYou can customize existing `FieldLensDeclaration`s with [`withDocumentation`](#withDocumentation) and [`withName`](#withName)\nor create custom lens ([`functionsForField`](#functionsForField) and [`getSetRecordForField`](#getSetRecordForField) can be helpful).\n\n    customLensDeclaration { fieldName } =\n        { documentation =\n            emptyDocComment\n                |> markdown\n                    (\"`CustomLens` for the field `.\" ++ fieldName ++ \"`.\")\n                |> Just\n        , name = fieldName\n        , annotation =\n            typed \"CustomLens\"\n                [ extRecordAnn \"record\"\n                    [ ( fieldName, typeVar fieldName ) ]\n                , typeVar fieldName\n                ]\n                |> Just\n        , implementation =\n            let\n                { access, set } =\n                    functionsForField fieldName\n            in\n            fqConstruct [ \"CustomLens\" ] \"create\" [ access, at ]\n        }\n\n","args":[],"type":"{ documentation : Maybe.Maybe (Elm.CodeGen.Comment Elm.CodeGen.DocComment), name : String.String, annotation : Maybe.Maybe Elm.CodeGen.TypeAnnotation, implementation : Elm.CodeGen.Expression }"},{"name":"FieldLensGenerator","comment":" How to generate a [`FieldLensDeclaration`](#FieldLensDeclaration) plus the necessary imports.\n\nOut of the box there are lenses for\n\n  - [`elm-accessors`](#accessors),\n  - [`elm-fields`](#fields),\n  - [`elm-monocle`](#monocle),\n  - [`zipper`](#zipper)\n\nYou can also create a custom one with the help of [the-sett's elm-syntax-dsl](https://package.elm-lang.org/packages/the-sett/elm-syntax-dsl/latest):\n\n    customLens : FieldLensGenerator\n    customLens  =\n        { imports =\n            [ importStmt [ \"CustomLens\" ]\n                Nothing\n                (exposeExplicit\n                    [ typeOrAliasExpose \"CustomLens\" ]\n                    |> Just\n                )\n        , declaration =\n            \\{ fieldName } ->\n                { documentation =\n                    emptyDocComment\n                        |> markdown\n                            (\"`CustomLens` for the field `.\" ++ fieldName ++ \"`.\")\n                        |> Just\n                , name = fieldName\n                , annotation =\n                    typed \"CustomLens\"\n                        [ extRecordAnn \"record\"\n                            [ ( fieldName, typeVar fieldName ) ]\n                        , typeVar fieldName\n                        ]\n                    |> Just\n                , implementation =\n                    let\n                        { access, set } =\n                            functionsForField fieldName\n                    in\n                    fqConstruct [ \"CustomLens\" ] \"create\" [ access, at ]\n                }\n        }\n\n","args":[],"type":"{ imports : List.List Elm.CodeGen.Import, declaration : { fieldName : String.String } -> NoMissingRecordFieldLens.FieldLensDeclaration }"}],"values":[{"name":"accessors","comment":" Generate lenses for [bChiquet's elm-accessors](https://package.elm-lang.org/packages/bChiquet/elm-accessors/latest) in the form\n\n    import Accessors exposing (Relation, makeOneToOne)\n\n    score : Relation score sub wrap -> Relation { record | score : score } sub wrap\n    score =\n        makeOneToOne .score (\\f r -> { r | score = f r.score })\n\n","type":"NoMissingRecordFieldLens.FieldLensGenerator"},{"name":"fields","comment":" Generate lenses for [sjorn3's elm-fields](https://package.elm-lang.org/packages/sjorn3/elm-fields/latest/) in the form\n\n    score :\n        { get : { a | score : score } -> score\n        , set : score -> { b | score : score } -> { b | score : score }\n        }\n    score =\n        { get = .score, set = \\score_ r -> { r | score = score_ } }\n\n","type":"NoMissingRecordFieldLens.FieldLensGenerator"},{"name":"functionsForField","comment":" The access, set and update functions for a record field.\n\n    functionsForField \"score\"\n    --> { access = accessFun \".score\"\n    --> , set =\n    -->     lambda\n    -->         [ varPattern \"score_\", varPattern \"r\" ]\n    -->         (update \"r\" [ ( \"score\", val \"score_\" ) ])\n    --> , update =\n    -->     lambda\n    -->         [ varPattern \"f\", varPattern \"r\" ]\n    -->         (update \"r\"\n    -->             [ ( \"score\"\n    -->               , construct \"f\" [ access (val \"r\") \"score\" ]\n    -->               )\n    -->             ]\n    -->         )\n    --> }\n\n","type":"String.String -> { access : Elm.CodeGen.Expression, set : Elm.CodeGen.Expression, update : Elm.CodeGen.Expression }"},{"name":"getSetRecordForField","comment":" Generate a field lens implementation in the form\n\n    { get = .score, set = \\score_ r -> { r | score = score_ } }\n\nThis is equivalent to\n\n    let\n        { access, set } =\n            functionsForField fieldName\n    in\n    CodeGen.record\n        [ ( \"get\", access ), ( \"set\", set ) ]\n\n","type":"String.String -> Elm.CodeGen.Expression"},{"name":"monocle","comment":" Generate lenses for [arturopala's elm-monocle](https://package.elm-lang.org/packages/arturopala/elm-monocle/latest) in the form\n\n    import Monocle.Lens exposing (Lens)\n\n    score : Lens { record | score : score } score\n    score =\n        { get = .score, set = \\score_ r -> { r | score = score_ } }\n\n","type":"NoMissingRecordFieldLens.FieldLensGenerator"},{"name":"rule","comment":" Reports record field lenses that are called in the code but don't exist yet and automatically generates them.\n\nExamples of such lenses are\n\n  - [bChiquet's elm-accessors](https://package.elm-lang.org/packages/bChiquet/elm-accessors/latest)\n  - [sjorn3's elm-fields](https://package.elm-lang.org/packages/sjorn3/elm-fields/latest/)\n  - [arturopala's elm-monocle](https://package.elm-lang.org/packages/arturopala/elm-monocle/latest)\n  - [zh5's zipper](https://package.elm-lang.org/packages/z5h/zipper/latest/)\n\n```\nconfig =\n    [ NoMissingRecordFieldLens.rule\n        { generate = NoMissingRecordFieldLens.accessors\n        , generateIn = ( \"Accessors\", [ \"Library\", \"Fields\" ] )\n        }\n    ]\n```\n\n  - `generate`: What kind of lens to generate:\n      - [`elm-accessors`](#accessors),\n      - [`elm-fields`](#fields),\n      - [`elm-monocle`](#monocle),\n      - [`zipper`](#zipper) or\n      - [a custom one](#FieldLensGenerator).\n\n  - `generateIn`: The module where all field lenses will be generated in\n\n    understand `( \"Accessors\", [ \"Library\", \"Fields\" ] )` as `Accessors.Library.Fields`\n\n\n## Example\n\n    module SomeModule exposing (scoreAPoint)\n\n    import Accessors.Library.Fields as Field\n\n    scoreAPoint =\n        Accessors.over Field.score ((+) 1)\n\n\n### Fail\n\n    module Accessors.Library.Fields exposing (name)\n\n    ...\n\n\n### Success\n\n    module Accessors.Library.Fields exposing (score)\n\n    ...\n\n","type":"NoMissingRecordFieldLens.Config -> Review.Rule.Rule"},{"name":"withDocumentation","comment":" The provided [`FieldLensGenerator`](#FieldLensGenerator)s in this package have no documentation comment.\n\nYou can generate your own documentation, though:\n\n    accessorsWithDocumentation { fieldName } =\n        accessors { fieldName = fieldName }\n            |> withDocumentation\n                (emptyDocComment\n                    |> markdown\n                        (\"Accessor for the field `.\" ++ fieldName ++ \"`.\")\n                )\n\n","type":"Elm.CodeGen.Comment Elm.CodeGen.DocComment -> NoMissingRecordFieldLens.FieldLensDeclaration -> NoMissingRecordFieldLens.FieldLensDeclaration"},{"name":"withName","comment":" The provided [`FieldLensGenerator`](#FieldLensGenerator)s in this package have no documentation comment.\n\nNothing is holding you back from generating your own documentation, though:\n\n    accessorsWithDocumentation { fieldName } =\n        accessors { fieldName = fieldName }\n            |> withDocumentation\n                (emptyDocComment\n                    |> markdown\n                        (\"Accessor for the field `.\" ++ fieldName ++ \"`.\")\n                )\n\n","type":"String.String -> NoMissingRecordFieldLens.FieldLensDeclaration -> NoMissingRecordFieldLens.FieldLensDeclaration"},{"name":"zipper","comment":" Generate lenses for [z5h's zipper](https://package.elm-lang.org/packages/z5h/zipper/latest/) in the form\n\n    import Zipper exposing (Zipper, into)\n\n    intoScore : Zipper { record | score : score } root -> Zipper score root\n    intoScore =\n        into .score (\\score_ r -> { r | score = score_ })\n\n","type":"NoMissingRecordFieldLens.FieldLensGenerator"}],"binops":[]}]